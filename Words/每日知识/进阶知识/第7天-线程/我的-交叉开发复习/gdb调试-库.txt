gcc和gdb
	gcc的编译过程
		gcc ***.c -o ***
		预编译：将宏定义、文件包含、条件编译事先替换
			gcc -E ***.c -o ***.i
			-E 预编译选项
		编译：将预处理完的文件进行一系列的语法分析、名词分析生成一个相应
			的汇编文件 -S
			gcc -S ***.i -o  ***.s
			
		汇编： 将汇编文件转换为相应的二进制（机器）可执行指令
			gcc -c a.s -o a.o
			-c 是汇编选项，将汇编文件编译成二进制文件
		
		ld 链接器，将多个目标文件，组合一起，生成一个机器可执行的文件（程序）
			包括相应的符号链接关系
			-e main  指定程序开始执行是从main函数开始
			-lc 指定链接了一个库文件 c ==》 libc.so libc.a
		★★★ld链接，只需要知道他的功能就可以了，不需要去纠结怎么使用
			因为在上层编程中，链接与操作系统息息相关，很难有一套统一的规则
			一般在底层开发时，不涉及系统的使用个，才好用链接

lib***.so   动态库文件
lib***.a	静态库文件
===》
	lib 前缀，表示该文件是一个库文件
	***  库名，库的名称
	.so	 后缀 表示该库是一个动态库
	.a	 后缀 表示该库是一个静态库
			
			
静态库与动态库的区别
	静态库：在程序编译时，会被链接到目标文件的代码中，程序在运行时
		就不需要这个静态库了！！！ （过河拆桥）
	动态库： 在程序编译时，只会记录相应需要被使用的代码在库中的位置
		运行程序时，当程序需要使用动态库的资源时，才跳转到动态库中执行
		相应的代码  （妈宝男），动态库在程序运行时，也要存在！！！
		
	库：黑匣子，让反编译的难度成倍上升
	将需要保密、或者公开给他人使用但要保护的核心部分，封装成库
	
	库文件都是依赖于 目标文件（.o）编译生成的
	
	
静态库
1. 编写需要封装成库的.C文件
2. 将.c文件汇编后生成目标文件
	gcc -c **.c -o **.o
3.将目标文件添加到静态库文件中
	语法： ar  crv lib***.a  ***.o
	含义： 将一系列的***.o 添加到静态库 lib***.a中
		ar  静态库编译命令，用来将目标文件添加到指定的静态库中
		c create，如果库文件不存在，则创建该库文件
		r 将列表中的目标文件添加到静态库中
		v 在ar命令执行过程中，打印更多的信息
	例如： sum.c 里面有一个求和函数
4.静态库的引用
	在编写需要使用他人第三方库时，必须要有相应的头文件
	在编译时，要通过编译选项指定库所在的路径（-L）和库名（-l）
	gcc ***.c -o ***  -L<libpath>  -l<libname>
	例如：
		gcc main.c -o main -L. -lsum
		
	
	gec@ubuntu:/mnt/hgfs/cs1803/交叉开发回顾/lib$ gcc main.c -o main
	/tmp/ccelnzvn.o：在函数‘main’中：
	main.c:(.text+0x19)：对‘sum’未定义的引用
	collect2: error: ld returned 1 exit status
	gec@ubuntu:/mnt/hgfs/cs1803/交叉开发回顾/lib$ gcc main.c -o main -L. -lsum
	gec@ubuntu:/mnt/hgfs/cs1803/交叉开发回顾/lib$ 
	
	练习：编写加减乘除库（4个），编写一个程序利用这四个库来做计算题
		
	
动态库
1. 编写需要封装成库的.C文件
2. 将.c文件汇编后生成目标文件
	gcc -c **.c -o **.o		
3.动态库的编译
		语法： gcc -shared -fpic ***.o  -o lib***.so
		含义：利用***.o 编译生成动态库 lib***.so
			-shared 指定生成动态库，如果在编译时没有使用这个选项，则编译生成的只是一个程序而已
				外部程序则无法调用该程序文件中的资源
			-fpic 编译为与位置无关的独立代码，如果不用则表示编译生成的代码段与位置相关，动态连接时
				则是通过拷贝来实现供给其他程序使用，不能真正体现动态库的性质
				
		gcc -shared -fpic sum.o jian.o cheng.o chu.o -o libmy_math.so
		
4.动态库的引用 与静态库的应用完全一致
		gcc ***.c  -o *** -L<libpath> -l<libname>
		
		
	★★★★★ 库文件在编译中，任意一个.c文件中，都不能存在main函数	
				如果同路径下，既存在静态库，也存在动态库，则编译器优先使用动态库
				开发者可以在编译时加上选项 -static 来选择使用静态库
				
				
		gec@ubuntu:/mnt/hgfs/cs1803/交叉开发回顾/lib$ gcc -shared -fpic sum.o jian.o cheng.o chu.o -o libmy_math.so
		gec@ubuntu:/mnt/hgfs/cs1803/交叉开发回顾/lib$ gcc main.c -o main -L. -lmy_math
		gec@ubuntu:/mnt/hgfs/cs1803/交叉开发回顾/lib$ ./main
		./main: error while loading shared libraries: libmy_math.so: cannot open shared object file: No such file or directory
		gec@ubuntu:/mnt/hgfs/cs1803/交叉开发回顾/lib$ 

		上述错误是 由于 动态库是"妈宝男“  在运行程序的时候，也需要存在，而系统对于动态库的搜索只会到指定的目录中
		由 LD_LIBREARY_PATH 环境变量指定
		所以您需要将您用到的库所在的路径添加到这个环境变量中
			您也可以把您的库放到 已经指定的目录中  /lib  /usr/lib
			
		1)sudo  vi /etc/profile
			在文件末尾处加上下列语句
			export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:<您的库所在的路径>
			比如：
			export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/mnt/hgfs/cs1803/交叉开发回顾/lib
			
		2) 在命令行执行上述语句
		
		
		添加到配置文件中，重启后生效，并且永久有效
		如果是在命令行执行，则重启终端后失效
		
		
		
	
gdb是 一个虚拟调试服务
	gdb调试的程序必须要编译时加上 -g选项，表示生成一个带调试符的程序
	
	语法 ：gcc -g ***.c -o ***
			adb ***
			====》 进入 adb的虚拟 界面，可以在该界面中执行gdb的指令
				回车默认执行上一个命令
				
			l  list，用来查看源代码文件
			
			start 开始运行，需要手动控制下一步执行
			r	run 运行，直接运行到断点或结束
			s 	下一步，遇上函数调用会进入调用函数执行，但不能进入库的函数
			n	下一步，不会进入函数执行
			c 	恢复运行，直到结束或遇到下一个断点
			
			b 函数名或行号  表示在相应位置设置断点
			delete 断点号   表示删除断点
			info b 查看断点
			
			
			
			f	退出当前函数，直到函数执行结束
			
			p 变量名	print 打印变量的值 
			
			
			q quit  退出gdb调试
			
		
		
		
		