运算符和表达式组成了c程序的基本语句

运算符的几目运算符表示什么意思呢？
	单目运算符：表示运算符链接一个操作数
	双目运算符：表示运算符链接两个操作数
	三目运算符：表示运算符链接三个操作数
	
运算符的结合性：
	计算在对数据进行处理时，不可能同时处理两个数据（单cpu）
	因此，设计到多目运算符时，这几个操作数到底先执行哪一个呢？
	从左往右结合：先运算左边的操作数，在运算右边的操作数
		a + b; a的值去加上b的值 
		b + a; b的值去加上a的值
	从右往左结合：先运算右边的操作数，再运算左边的操作数
		a = b; 将b的值赋值给a的地址

	多个运算符在一个表达式中时，结合性看各类运算符的优先级
优先级：
	单目运算符>算术运算符>关系运算符>逻辑运算符>条件运算符>赋值运算符>逗号运算符
	如果您实在记不住这些优先级怎么办？？
	()括号是很有帮助了	
	2+1*3 = 5;
	(2+1)*3 = 9;


运算符：对数据进行操作的符号被称为运算符
	算术运算符：算术运算符是用来进行某种算术运算的
		单目： ++  -- 自运算符
			用法： 左值++  ++左值
				   左值--  --左值
			由于++ 和 -- 会改变操作数的值，
				因此操作数必须是一个可读可写的地址（左值）
				
			int a = 3;
			int b = 4;
			a++；
			b--;
			(a+b)++; //详见1.c
			
					表达式的值         运算完成后的结果
		i++				i					i+1
		++i				i+1					i+1
		i--				i					i-1
		--i             i-1					i-1
		//详见2.c
		规律：自运算符在前则先 加/减 再运算
			  自运算符在后则先运算在加/减
		双目：+ - * / % ....
		整数的运算结果只会是整数
		
		a+++b //见2.c
		
		a++++;
		++a++;
		++++a;
		上面三个都是错误的，错误原因都是第二次++时
			已经不是对左值操作了！！！
		
		5/2=2;
		5.2%2这中表达式是错误的，
			%符两边只能是整数
			
		/和% 右边的数不能为0
		5/0   5%0
		
		对于/运算符，如果两边都是整数，此运算符为取整运算
					如果说左边是浮点型，并且运算结果赋值给浮点型
					此运算符做 算术除
			
		int a = 5.2/2;	  a = 2;
		float a = 5.2/2;  a == 2.6
		
		float a = 3.5 + 3.6/2;  
		int a = 3.5 + 3.6/2;
		
	关系运算符：用来比较数据的关系
		双目运算符，结合性从左到右
		<   <=  > >= == !=  
		注意：在c语言中逻辑表达式与数学中的逻辑表达式不能通用
		比如：
			数学表达式：10<x<100; x要大于10并且小于100
			这种表达式在c语言中是不被识别的
			c语言将上述表达式识别为：
				10<x 如果为真，其值为1， 1<100 => 1
					 如果为假，其值为0,  0<100 => 1
		关系表达式的结果有两种
			如果表达式为真，表达式的值等于1
			如果表达式为假，表达式的值等于0
			
		int a = 5;
		int b = a > 4 > 3;
		printf("%d\n",b); //0


​				
	逻辑运算符：双目运算符  结合性从左到右
		非0即为真
		0为假
		&&　　逻辑与:有0为0,全1为1
		||    逻辑或:有1为1,全0为0
		!	  逻辑非(单目运算符):真为假,假为真
		
		在c语言中,运算是具有惰性的!!!
		1 && 2 && 3 && 4
		0 && 1 && 2 && 3 && ......
		如果说,前面的操作数已经能够得出表达式的结果了,
			那么计算机不会去运算后面的操作数,这就是惰性
	int a,b,c,d,m,n;
	a = 1;b = 2; c = 3;d = 4;
	(m = a>b) && (n = c > d);
	printf("a=%d b=%d c=%d d=%d m=%d n=%d\n",a,b,c,d,m,n);
		
			对于 && 来说
			表达式        结果
			1 && 1         1
			1 && 0 		   0
			0 && 1 		   0
			0 && 0		   0
			1 && x		   x
			0 && x		   0
			
			1逻辑与上任意一个数，其表达式由 ”任意一个数“决定
			0逻辑与上任意一个数，其表达式的值都为 0（惰性）
			
			对于 || 来说
			表达式         结果
			1 || x			1
			0 || x			x
			0逻辑或上任意一个数，其表达是由”任意一个数“决定
			1逻辑或上任意一个数，其表达式的值都为1（惰性）
			
			对于 ! 来说
			!0    为真
			!1    为假
			
			a && b || !c 
			运算过程：
				a && b 如果为 真 则表达式值为 1
	练习：
		1、
		int a = 3;
		int b = 4;
		int c = a || b+a && b-a || a++;
		printf("a=%d b=%d c=%d\n",a,b,c);//  3 4 1
		
		2、
		int a = 1;
		int b = -1;
		a = a<b || a>b && b=a&&b;
		printf("a=%d b=%d\n",a,b);
		
		3、
		int a = 1;
		int b = 1;
		int c = --a || b&&a-- > 0;//b&&a-- >0 先运算 a-- > 0?
		printf("c=%d\n",c);


​		
		int i = 3;
				
		int a = i++ + i++ + i++ + i++ + i++ + i++ + i++;
		printf("i=%d a=%d\n",i,a);// 10 21?
		编程的时候，避免使用上述操作
		不同的编译器的解释方式不同
		
		设y是1-2018年中的某一年
			试用逻辑表达式，写出一个判断y是不是闰年的表达式
			（1）y能被4整除，但不能被100整除
					y%4==0 && y%100!=0 
			（2）y能被4整除，并且能被400整除 
					y%4==0 && y%400==0
			满足以上两个条件中的任意一个，那么y都是闰年
		
		int main(void)
		{
			int y = 1234;
			/*
			if(y%4==0 && y%100!=0)
				printf("%d 是闰年\n");
			if(y%4==0 && y%400==0)
				printf("%d 是闰年\n");
			*/
			if((y%4==0 && y%100!=0) || (y%4==0 && y%400==0))
		}
		逻辑关系符中：! > && > ||


​		
	位运算符：按照bit位进行运算的操作符
		对于位操作来说，被操作的数只能是整数
		（整型、短型、长型、字符型）
		在进行位运算时，需要先将整数转换位二进制数在操作
		&:按位与
			1 & 1 = 1
			1 & 0 = 0
			0 & 1 = 0
			0 & 0 = 0
			
		比如：	
			int a = 3;
			int b = 4;
			int c = a & b; //0
			过程：
			00000000 00000000 00000000 00000011 (3)
			00000000 00000000 00000000 00000100 (4)
		   &00000000 00000000 00000000 00000000 (0)	
		用途：	
		（1）按位与常用与就将一个数的某些位取出来
			比如 将 0x89abcdef 的第 12位到第18位取出来（标号从0开始）
			
				1000 1001 1010 1011 1100 1101 1110 1111 （0x89abcdef）
			   &0000 0000 0000 0111 1111 0000 0000 0000	 (0x0007f000)
				0000 0000 0000 0011 1100 0000 0000 0000  (0x3c000)
			练习：有1个数是0x12345，要求取出第9位
			 0x12345 & 0x200 = 0x200;
			 
			 要取出某几个比特位，就是按位与上一个对应位为1的数
		（2）清0指定位：按位与上对应位为0，并且其它位为1的数
			char a = 0xff; //清零低4位
			思路：清零低4位也就是说，低4位为0，其它位为1
			---》所以这个数是 1111 0000 (0xf0)
				1111 1111 （0xff）
			  &	1111 0000 （0xf0）
			  ————————————————————
				1111 0000 （0xf0）
				
				清零 0x34的 第3到第6位  1000 0111 (0x87)
				0011 0100  (0x34)
			  &	1000 0111  (0x87)
			 ————————————————————
				0000 0100  (0x4)
		(3)保留指定位：按位与上对应位为1的数，并且其它位为0
			
		练习：1、取出int a = 1234; 的 第5到第11位
				1234 = 1024 + 128 + 64 + 16 + 2
				0000 0000 0000 0000 0000 0100 1101 0010 (1234)
			  &	0000 0000 0000 0000 0000 1111 1110 0000 (0xfe0)
				0000 0000 0000 0000 0000 0100 1100 0000 (0x4c0)
			  2、清0取出来的数的第8和10位(第8和10位为0，其它位为1)
				0x4c0 & x;
				0000 0000 0000 0000 0000 0100 1100 0000 (0x4c0)
			  &	1111 1111 1111 1111 1111 1010 1111 1111 
			    0000 0000 0000 0000 0000 0000 1100 0000 （0xc0）
				
			  3、 9 & 5 =？
				  0000 1001 (9)
				 &0000 0101 (5)
				  0000 0001 (1)
				  
				  182 & 37 = ？
				  1011 0110 (182)
				 &0010 0101 (37)
				  0010 0100 (36)
				  
				  -15 & 3 = ？
				  |-15|:
				  0000 1111  (15)
				  1111 0000  (取反)
				  1111 0001  (-15)
				 &0000 0011   (3)
				  0000 0001   (1)
				  
			按位与操作：
				按位与1保持不变
				按位与0为0
				
		|：按位或
			1 | 1 = 1
			1 | 0 = 1
			0 | 1 = 1
			0 | 0 = 0
			按位或操作：
				 或1为1
				 或0保持不变
			常用来将指定位置1
			比如：char c = 0x01 | 0xf0;
				  0000 0001  （0x01）
				| 1111 0000   (0xf0)
				——————————————————
				  1111 0001   （0xf1）
		   5 | 9 = ?
		   0000 0101  (5)
		 | 0000 1001  (9)
		 ————————————————
		   0000 1101  (13  0xd)
		   
		 练习：将0x12345678的最高16位置1  | 0xffff0000
				同时最低8位置0 & 0xffffff00 
			0001 0010 0011 0100 0101 0110 0111 1000 （0x12345678）	
		|   1111 1111 1111 1111 0000 0000 0000 0000	 （0xffff0000）	
		&	1111 1111 1111 1111 1111 1111 0000 0000  (0xffffff00)	
			1111 1111 1111 1111 0101 0110 0000 0000	 (0xffff5600)
		////////////////////////////////////////////////////////// 
		 求 0x12345678 | 0xffff0000 & 0xffffff00 = ?
			0x12345678 | 0xffff0000
			0xffff5678		 
		 提示：同类运算符同样具有优先级  & > |
		
		~：按位取反（非）,单目运算符，除~以外都是双目运算符
			~1 = 0；
			~0 = 1；
			  ~10086 = ？
			 0000 0000 0000 0000 0010 0111 0110 0110 （10086）
			 1111 1111 1111 1111 1101 1000 1001 1001  （~10086）
			 
		^：按位异或（求异）：不同为1 相同为0
			1 ^ 0 = 1
			1 ^ 1 = 0
			0 ^ 1 = 1
			0 ^ 0 = 0
			与1按位异或翻转
			与0按位异或保持不变
			作用：一般用来将特定位置翻转
					翻转---》0变1 1变0
					
					比如：将char a = 0x12;的高4位翻转
					  方法：让高4位异或1，低4位异或0
					   0x12 ^ 0xf0 = 
					   0001 0010 (0x12)
					  ^1111 0000 (0xf0)
					   1110 0010 (0xe2)
				  交换两个数的位置
				  比如：char a = 5;
						char b = 9;
						------> a = 9; b = 5;
						a = a^b;
							0000 0101  (a 5)
						   ^0000 1001  (b 9)
							0000 1100  (a 12)
						b = a^b;
							0000 1100  (a 12)
						   ^0000 1001  (b 9)
						    0000 0101  (b 5)
						a = a^b;
							0000 1100  (a 12)
						   ^0000 0101  (b 5)
						    0000 1001  (a 9)
		记住一点：：：位操作是将整数转换成二进制位再一位一位的操作
	作业：
		1、分别用算术表达式 和 位运算 将两个数不借助第三个数转换位置
			比如：
				char a = 77;
				char b = 88;
				 ----> a = 88; b = 77;
				 
		2、char a = 253;
		   char b = a + 255;
		   printf("%d\n",b);
		   printf("%u\n",b);
		   
		3、int a = 0x13579;
		   int b = 0x24680;
		   求 ~a ^ b | a & b
		
		~ > & > ^ > |
	
		<<：按位左移
		>>：按位右移


​	
	赋值运算符：
	逗号运算符：
		int i,j,k;int main(int argc,char *argv)
	条件运算符：
		？：
	指针运算符：
		*取值符
		&取址符
	求字节运算符：
		sizeof(int) = 4
	强转运算符：
		(数据类型)变量
		char a；
		printf("%d\n",(int)a);
	分量运算符：
		.   ->:在结构体中用来访问结构体成员
	下标运算符：
		[]
		int a[10];
		a[0]~a[9];
	其它运算符：
		函数调用运算符
		返回值 = 函数名(有无成函数传递);//函数调用表达式
		函数调用表达式的值是什么？？？
		函数调用表达式的值就是执行该函数后的那个返回值
			也就是return 后面接的那个表达式的值
		
		比如说，您老师很喜欢在main函数最后面写一个
		return 0;
		这个0就是main函数的返回值
		
		为什么返回0呢？
		这是程序界的一个潜规则，在函数返回值是int型的时候
		返回0表示程序运行没有错误
		返回-1表示程序运行是错误结束的


​		
​		

表达式：表达某种意思的句子被称为表达式
	在c语言中表达式一般指用运算符和操作数组成的式子
	是一个表达式就一定会有一个值，表达是的值就是“某种意思”
	
	
	
	
