有一个数组
	a[10] = {1,2,3,4,5,6,7,8,9};
	利用指针的方式,将数组倒叙输出
	//0x12345678
	指针:指向一个地址的!!指针在数值上就是这个指向的地址的编号
	
	数组名就是一个指针,指向的是数组第一个元素的地址(首地址)
	
	数组元素的表述方式:
					数组下标			指针加减
	第一元素          a[0]                  *a
	第二元素		  a[1]				    *(a+1)
	第三元素		  a[2]					*(a+2)
	....
	第N元素			  a[N-1]            	*(a+N-1)
	
	*a+1 ===> a[0] + 1 
	*(a+1) === >a[1]
	
	
	
	void print(int* p,int n)
	{
		/*
		printf("%d ",*(p+n-1));
		printf("%d ",*(p+n-2));
		printf("%d ",*(p+n-3));
		....
		printf("%d \n",*p);
		*/
		while(n>0)
		{
			n--;
			printf("%d ",*(p+n));
		}
		printf("\n");
	}
	
	/*
		p指向数组首地址
		e指向数组末尾地址
	*/
	void　print_mmm(int *p,int *e)
	{
		while(e>=p)
		{
			printf("%d ",*e--);
		}
		printf("\n");
	}
	
	int main(void)
	{
		int a[10] = {1,2,3,4,5,6,7,8,9};
		print(a,9);
		print_mmm(&a[0],&a[8]);
	}
	
	
	
1.再论数组和指针
	数组名是一个指针,指向的是数组第一个元素的地址
	并且数组名是一个常量指针 (数组名++ 是错误的)
	
	数组的类型是什么???
	比如说  int a[10];  //a的类型是 int[10];
	  //从指针的角度来说,a是一个指向int型变量的指针
	typeof(a) * p = a; // int[10] * p = a;   错误的!!!
	
	原因是: a指向的是数组的第一个元素,是 int*
		同时a在数值上来说是 a[0]的地址
		
		对于上述的p来说,
			p是指向 一个 int[10] 的指针  int[10]*
			------> int * [10];
			
	这里的p被称为数组指针,正确定义方式应该如下
	typeof(a) *p = &a;  ===> typeof(a) <===> int[10]
	int[10] * p; //p指向一个数组,这个数组具有10个int元素
	
	
	
	int b[3][4] = {
			{1,2,3,4},
			{5,6,7,8},
			{9,8,7,6}
			};
	问:数组名b指向的是谁???  {1,2,3,4} ==> b[0] ===> int[4][3]
				从指针的角度来书 b指向一个数组,这个数组有4个int型元素
		怎么用一个指针指向b[0][0]??
			b[0][0] 是一个int型变量---> 定义一个指向int型的指针
			int *p = &b[0][0];
		b+1 指向谁?b[1]
	------->数组指针是一个行指针
		
		怎么用一个指针指向 b = &b[0]
			int[4] *b <===> int b[3][4];
		
		怎么用一个指针指向数组b? int[4][3]
			int[4][3] * p = b;
			p+1 ---> b+3;
	
		
	int[4] b[3];
	c语言中只有一维数组,所谓的二维数组只是一维数组的每个元素都是数组
	
	
		
	数组名 和 数组指针的区别:
		数组名是指向数组的第一个元素的地址
		数组指针指向的是那整个数组(首地址)
		
		从数值上来说,数组名和数组指针指向的地址是相同的
		(数值相同/地址的编号相同)
		设数组首地址是0x123456
		int a[10];
		typeof(a) *p = a;
		a+1 == 0x12345a == 0x123456 + 4
		p+1 == 0x12347e == 0x123456 + 40
		a+1<<<<<<<<(远大于)p+1
	
	数组指针的定义:指向数组的指针
	数组类型 * 指针名;
	===>数据类型 (*指针名)[];
	
	指针指向地址  
	指针也是一个变量 指针 = &变量
	指针再次指向指针 指针 = &指针  ---->二级指针
	
	
****指针:
	指针是指向一个地址的,
	并且指针的类型是指向的那个数据的类型
	指针在数值上就是那个地址的编号
	如果把指针当成一个普通变量,
		指针存放的就是一个十六进制的整数
	
2.指针数组
	指针数组:是一个数组,数组的成员是指针
	数组指针:是一个指针,指向一个数组的地址
	定义一个指针数组呢?
	数组元素类型* 数组名[数组容量]
		比如 int* a[10];
			表示定义一个拥有十个元素的数组,
			数组的每个元素都是一个 int*(指向int型的指针)
	
	
	初始化赋值:
		int a[5] = {1,2,3,4,5};
		int b[10] = {7,8,5,23,2};
		int c = 7;
		int d[2] = {1,2};
		int* k[10] = {a,b,&c,d};
		int* t[10] = {
				{1,2,3,4,5},
				{6,3,5,4,2,2,3,4,5,6},
				{1,2,3},
				{1}			
			};
			
	对于指针数组的初始化来说,初始化赋值时没有全部赋值的化
	后面的没赋值部分自动赋值为NULL(空指针,指向一个空地址)
	
	NULL:空指针,指向一个不能 被操作的空间
			
	int a[3][4];
================================================================
					含义						表达式值
	a       表示整个二维数组
		    表示二维数组的第一个一维数组
			typeof(a[0])* ==>int[4] *            &a[0]
			
	a[0]    表示一个一维数组
			表示一维数组的第一个元素
			typeof(a[0][0])* ==> int *           &a[0][0]
			
	a[0][0] 变量,与普通变量一致
			&a[0][0],是a[0]一维数组的首地址
			typeof(a[0][0])  ==> int 			 a[0][0]
=================================================================
	
	a+1		表示的是二维数组的第二个一维数组
			&a[0] + 1							 &a[1] (第二行)
			&a[1]
			int[4]* + 1
			
	&a[1]	指针,指向二维数组的第二个一维数组
			typeof(a[1]) *						&a[1]
			
	&a      指针,指向二维数组a
			typeof(a)*
			int[4][3] *                         &a
												在数值上就是a[0][0]地址(&a[0][0])
	
	&a+1   	表示跳过整个二维数组a的存储空间
			表示的是a[2][3]后面的那个地址       3*4*4 + &a[0][0]1
												
			
			
	有一个二维数组a[3][4];
	通过所有您已知的方式 对 a[2][2] 赋值 1024
	 
	a[2][2] = 1024;  //直接赋值
	int *q = &a[2][2]; //int *q;q = &a[2][2];
	*q = 1024; //通过变量地址间接赋值
	*(a[2]+2) = 1024;//a[2]表示的是二维数组的第三个(行下标为2)一维数组
	
	int (*w)[3][4] = &a; //指针w指向整个数组a
		w == &a; 
		*w == *(&a);
		*w == a;
		a[0] == &a[0][0];
		a == &a[0]; //a是数组名,是常量指针,指向数组的第一个元素
				//对于二维数组来说,第一个元素就是第一个一维数组
		*w == &a[0]
		*w+2 == &a[2]
		*w+2 == a + 2  == &a[2]
		*(*w+2) ==*(&a[2]) == a[2]
		*(*(*w+2)+2) == *(a[2] + 2) == *(&a[2][2]) == a[2][2]
	*(*(*w+2)+2) = 1024;
	
	
	int a[10] = {1,2,3,4,5,6,7,8,9,0};  //---->a       x
	
	int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};//----> b    y
	
	printf("a:%p  a+1:%p  &a+1:%p\n",a,a+1,&a+1);
	
	printf("b:%p  b+1:%p &b[0]:%p &b+1:%p\n",b,b+1,&b[0],&b+1);
	
3.字符串 和 指针
	
	c语言中没有字符串类型,c语言是用过用一个char*来实现字符串的
		char *:表示一个指向字符型的指针
	用""引起来的就被称为字符串
		比如"字符串" ---> 就是一个字符串
	字符串会在结尾自动添加'\0',用来表示字符串到此结束了
	
	有字符串如下
		"123456789"  ---->该字符串在内存中占10个字节
	字符串都是常量,字符串是存放在内存的 .rodata段,是只读的数据,不能被改变
	int main(void)
	{
		char *s = "123456789";
		s++; //是向后指向一个地址
		*s++;//取s地址的变量后s向后移动
		*(s+1);//取s后面的那个地址的变量
		s = &a; //a是一个char型变量  将s改指向 a的地址
		*(s+1) = 'A'; //给s后面地址的变量赋值为'A'
	}
	
	
	------>如果用指向char型的指针指向一个字符串,
			那么该指针指向的是字符串的首地址
			
	写一个函数,实现两个字符串比较(strcmp):通过字符串中每个字符的大小来比较		
	
	
	
4.字符串的操作函数
	输入函数:
		gets
		char *gets(char *s);
			参数:s:字符指针,需要以指向某个能够存放字符数据的地址空间
		返回值:获取到的字符串的存放地址(首地址)
		
		gets是用来从键盘获取字符串给指定的 "字符指针"
		char *p; //p指向任意地方,很危险!!
		p = gets();// p指针指向 gets获取到的字符串的首地址
		
		char *t = malloc(100);
		gets(t); //从键盘获取字符串,并存入t指针指向的地址
		
		gets(p); //不能用!!!! p只是一个指针,并没有空间
****gets的参数必须是一个已经分配了空间的字符指针(字符数组,malloc/realloc/calloc)	
------------------------------------------------------------------------		
	输出函数:
		puts将s指针指向的那个字符串输出到终端(打印)
		int puts(const char *s);
			参数:s表示要输出的字符串  
			puts(p);  <==>  printf("%s\n",p);
		
---------------------------------------------------------------------------		
	长度函数
		strlen:求字符串s的长度
		NAME
       strlen - calculate the length of a string

		SYNOPSIS
       #include <string.h>

       size_t strlen(const char *s);
****strlen求长度是遇到'\0'才截止

-----------------------------------------------------------------------------		
	比较函数
		strcmp/strncmp
		NAME
       strcmp, strncmp - compare two strings

		SYNOPSIS
       #include <string.h>
			strcmp:比较字符串s1和字符串s2的大小
			根据两个字符串的每个字符ASCII码来一一比较
       int strcmp(const char *s1, const char *s2);
			返回值: >0 表示 s1大于s2
					<0 表示 s1 小于s2
					==0 s1和s2中每个字符都相等
					
			strncmp:比较两个字符串的前n个是否相等
       int strncmp(const char *s1, const char *s2, size_t n);
****
	char *p = "abcd";
	char *q = "abcd";  
	//p指针和q指针指向的是  同一个地址!!!!!
	printf("%p  %p\n",p,q);

-----------------------------------------------------------------------	
	拷贝函数
		strcpy/strncpy
		NAME
       strcpy, strncpy - copy a string

	SYNOPSIS
       #include <string.h>
			strcpy将src字符串拷贝到dest字符串中,会整体拷贝,包括后面的'\0'
       char *strcpy(char *dest, const char *src);
			strncpy拷贝src的前n个字符 存放到dest指向存储空间中
	   char *strncpy(char *dest, const char *src, size_t n);
			从dest的第一个字符开始"替换"
--------------------------------------------------------------------------

		
	追加粘贴函数
		strcat/strncat
--------------------------------------------------------------------------		
	查找子字符串函数
		strstr
		NAME
       strstr, strcasestr - locate a substring

		SYNOPSIS
       #include <string.h>
			strstr用来在haystack中查找与needle相同的子字符串(查找)
       char *strstr(const char *haystack, const char *needle);

		返回值:失败返回NULL
			成功返回值找到的子字符串的首地址
			
		比如:
			strstr("ouyanghualiang","liang");
			
			
如果有一个数 是 12345678910111213141516 * 16151413121110987654321
	利用字符数组做大数据乘法
	char a[] = {'1','2',3,4,5,6,7,8,...,1,5,1,6};
	char b[] = {'1','6',.............,5,4,3,2,1};
	char tmp[] = ?
	char num[] = ?
	
	
	
5.函数指针:指向函数的指针
	c语言中,函数的也是有地址的,我们可不可以用一个指针指向这个地址呢??
	这类指向函数的指针就被称为函数指针
	函数名 其实就是个函数指针,指向的是函数的入口地址(首地址)
	
	(1)定义:
		指向类型 * 指针变量名;
		int sum(int a,int b)
		{
			return a+b;
		}
		
		typeof(sum) ---> 具有一个int返回值,并且需要两个int参数的 函数类型
		typeof(sum) *p;
		
		函数的三个要素:返回值  函数名  函数的参数
		====>int(int ,int) *p;
			====> int (*p)(int,int);
				====>int sum(int ,int);//函数声明
				
		函数指针的定义格式:
			指向函数的返回值类型 (*指针变量名)(指向函数的参数列表);
			
			比如: int (*fun_sum)(int,int);
				表示定义了一个fun_sum指针,指向一个具有
					int型返回值,并且需要两个int型参数的函数
	
	(2)函数指针的赋值
		int a = 10;
		int *p ;
		p = &a;
		
		int *q;
		q = p;
		
		int sum(int a,int b)
		{
			return a+b;
		}
		
		int (*fun_sum)(int ,int );
		fun_sum = sum; //指针fun_sum指向 sum函数的入口地址
		//fun_sum = &sum;
	(3)如何通过函数指针,调用函数
		sum(3,4);
		fun_sum = sum;
		//fun_sum = &sum;
		====>fun_sum(3,4);
			//(*fun_sum)(3,4);
	
	
	int a[10] = {1,2,3,4,5};
	int (*p)[10] = a; //步长为4
	int (*p)[10] = &a; //步长为40
	
	
	练习:写一个函数,该函数的功能是求一个二维数组所有元素之和
			要求:用函数指针实现
			
			
	指针函数:是一个函数,函数的返回值是一个指针型
		比如 char *my_strcpy(char *a,char *b);
			 char *(*my_fun)(char*,int );
			 
			 
			 
			 
6.动态分配
	char *p;
	*p = 'a'; //不可以,p是一个野指针
	想让一个指针帮您存储数据,那么必须要让这个指针指向一块能过存放数据的空间
	======>动态分配
	
	malloc/realloc/calloc/free
	
	动态分配:指的是随时随地根据开发人员的需求为指针分配指定大小的空间
		动态分配的空间 是 堆 中的空间,分配的空间系统不会自动回收资源
		也就是说,分配了空间就一直被占用了,哪怕您的函数已经结束了!!!!
		因此,动态分配的空间在不使用以后,一定要记得释放(free)
		
	变量内存的生存周期:
		随函数持续性:函数运行结束后,分配给变量的空间自动回收
			int a = 4; //局部变量,只在函数类有效,分配给局部变量的空间
						//系统会在函数执行完后自动回收
		随进程持续性:分配给变量的空间会一直存在,直到程序运行结束
			进程:程序的一次执行过程
			所有动态分配的空间,都是随进程持续性
			char *p = malloc(1000);
				//函数执行完后,p就会不见了(p是局部变量)
				//但是这1000个字节的空间,任然被占用了,
					//系统不会再使用这1000个字节的地址了
	
		malloc:用来动态分配一个size大小的空间,单位为字节
				分配完成后,还会返回首地址
				
		MALLOC(3)                  Linux Programmer's Manual                 MALLOC(3)

	NAME
       malloc, free, calloc, realloc - allocate and free dynamic memory

	SYNOPSIS
       #include <stdlib.h>
		malloc:用来动态分配一个size大小的空间,单位为字节
				分配完成后,还会返回首地址
       void *malloc(size_t size);
			size:要分配的空间的大小,单位字节
			返回值:分配的那块size大小空间的首地址
			
			free:用来释放ptr所指向的那块动态分配的空间
			给谁分配了空间,不用了,那就free谁
       void free(void *ptr);
			ptr:指向要释放空间的那个指针
			
	比如: char *p = malloc(sizeof(p)*4); //p指针分配了一块有 4*4=16 个字节的空间
		  *p = 'n';
		  *(p+1) = 'i';
		  *(p+2) = 'd';
		  *(p+3) = 'o';
		  *(p+4) = 'n';
		  *(p+5) = 'g';
		  //....
		  *(p+15) = '!'; //你懂  !
		  //以上表达式操作是正确的,因为p指针已经动态分配了空间
			//并且这块空间在 堆 中,是可读可写的
			
		calloc类似于malloc,都是用来动态分配给指针一块区间的
		calloc是以数组的形式分配空间,需要两个参数
       void *calloc(size_t nmemb, size_t size);
			nmemb:表示要分配几个空间
			size:表示每个空间分配几个字节
			calloc总共分配的大小为 nmemb*size
		返回值:返回分配空间的首地址,不使用的时候,切记free掉
		int * t = (int*)calloc(10,sizeof(int)); <==> (int*)malloc(10*sizeof(int));
			t所指向空间的大小为 : 10 * 4 = 40 个字节
			
			realloc是用来扩展一块已经动态分配好的空间
			一般在你觉得第一次动态分配的空间不够用的时候会用上它!!
       void *realloc(void *ptr, size_t size);
			ptr:指向要扩展内存的那个地址空间(指针)
			size:要扩展多大的内存
				== 0:表示不扩展
				> 0 :表示扩展多少个字节的内存,
					扩展后内存的大小为 原大小 + size
				< 0 :作者没有考虑过
		返回值:分配完后的那个空间的首地址
			比如: char *p = (char*)malloc(10086);
					sizeof(p) == 4;
					sizeof(*p) == 1;
				p = realloc(p,10010); // 10086+10010 = 20096个字节
		
		
****注意:动态分配的空间都是char型的空间,赋值给不同类型的指针时,记得强转一下


