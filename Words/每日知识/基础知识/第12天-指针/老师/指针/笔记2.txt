有一个数组
	a[10] = {1,2,3,4,5,6,7,8,9};
	利用指针的方式,将数组倒叙输出
	//0x12345678
	指针:指向一个地址的!!指针在数值上就是这个指向的地址的编号
	
	数组名就是一个指针,指向的是数组第一个元素的地址(首地址)
	
	数组元素的表述方式:
					数组下标			指针加减
	第一元素          a[0]                  *a
	第二元素		  a[1]				    *(a+1)
	第三元素		  a[2]					*(a+2)
	....
	第N元素			  a[N-1]            	*(a+N-1)
	
	*a+1 ===> a[0] + 1 
	*(a+1) === >a[1]
	
	
	
	void print(int* p,int n)
	{
		/*
		printf("%d ",*(p+n-1));
		printf("%d ",*(p+n-2));
		printf("%d ",*(p+n-3));
		....
		printf("%d \n",*p);
		*/
		while(n>0)
		{
			n--;
			printf("%d ",*(p+n));
		}
		printf("\n");
	}
	
	/*
		p指向数组首地址
		e指向数组末尾地址
	*/
	void　print_mmm(int *p,int *e)
	{
		while(e>=p)
		{
			printf("%d ",*e--);
		}
		printf("\n");
	}
	
	int main(void)
	{
		int a[10] = {1,2,3,4,5,6,7,8,9};
		print(a,9);
		print_mmm(&a[0],&a[8]);
	}
	
	
	
1.再论数组和指针
	数组名是一个指针,指向的是数组第一个元素的地址
	并且数组名是一个常量指针 (数组名++ 是错误的)
	
	数组的类型是什么???
	比如说  int a[10];  //a的类型是 int[10];
	  //从指针的角度来说,a是一个指向int型变量的指针
	typeof(a) * p = a; // int[10] * p = a;   错误的!!!
	
	原因是: a指向的是数组的第一个元素,是 int*
		同时a在数值上来说是 a[0]的地址
		
		对于上述的p来说,
			p是指向 一个 int[10] 的指针  int[10]*
			------> int * [10];
			
	这里的p被称为数组指针,正确定义方式应该如下
	typeof(a) *p = &a;  ===> typeof(a) <===> int[10]
	int[10] * p; //p指向一个数组,这个数组具有10个int元素
	
	
	
	int b[3][4] = {
			{1,2,3,4},
			{5,6,7,8},
			{9,8,7,6}
			};
	问:数组名b指向的是谁???  {1,2,3,4} ==> b[0] ===> int[4][3]
				从指针的角度来书 b指向一个数组,这个数组有4个int型元素
		怎么用一个指针指向b[0][0]??
			b[0][0] 是一个int型变量---> 定义一个指向int型的指针
			int *p = &b[0][0];
		b+1 指向谁?b[1]
	------->数组指针是一个行指针
		
		怎么用一个指针指向 b = &b[0]
			int[4] *b <===> int b[3][4];
		
		怎么用一个指针指向数组b? int[4][3]
			int[4][3] * p = b;
			p+1 ---> b+3;
	
		
	int[4] b[3];
	c语言中只有一维数组,所谓的二维数组只是一维数组的每个元素都是数组
	
	
		
	数组名 和 数组指针的区别:
		数组名是指向数组的第一个元素的地址
		数组指针指向的是那整个数组(首地址)
		
		从数值上来说,数组名和数组指针指向的地址是相同的
		(数值相同/地址的编号相同)
		设数组首地址是0x123456
		int a[10];
		typeof(a) *p = a;
		a+1 == 0x12345a == 0x123456 + 4
		p+1 == 0x12347e == 0x123456 + 40
		a+1<<<<<<<<(远大于)p+1
	
	数组指针的定义:指向数组的指针
	数组类型 * 指针名;
	===>数据类型 (*指针名)[];
	
	指针指向地址  
	指针也是一个变量 指针 = &变量
	指针再次指向指针 指针 = &指针  ---->二级指针
	
	
****指针:
	指针是指向一个地址的,
	并且指针的类型是指向的那个数据的类型
	指针在数值上就是那个地址的编号
	如果把指针当成一个普通变量,
		指针存放的就是一个十六进制的整数
	
2.指针数组
	指针数组:是一个数组,数组的成员是指针
	数组指针:是一个指针,指向一个数组的地址
	定义一个指针数组呢?
	数组元素类型* 数组名[数组容量]
		比如 int* a[10];
			表示定义一个拥有十个元素的数组,
			数组的每个元素都是一个 int*(指向int型的指针)
	
	
	初始化赋值:
		int a[5] = {1,2,3,4,5};
		int b[10] = {7,8,5,23,2};
		int c = 7;
		int d[2] = {1,2};
		int* k[10] = {a,b,&c,d};
		int* t[10] = {
				{1,2,3,4,5},
				{6,3,5,4,2,2,3,4,5,6},
				{1,2,3},
				{1}			
			};
			
	对于指针数组的初始化来说,初始化赋值时没有全部赋值的化
	后面的没赋值部分自动赋值为NULL(空指针,指向一个空地址)
	
	NULL:空指针,指向一个不能 被操作的空间
			
	int a[3][4];
================================================================
					含义						表达式值
	a       表示整个二维数组
		    表示二维数组的第一个一维数组
			typeof(a[0])* ==>int[4] *            &a[0]
			
	a[0]    表示一个一维数组
			表示一维数组的第一个元素
			typeof(a[0][0])* ==> int *           &a[0][0]
			
	a[0][0] 变量,与普通变量一致
			&a[0][0],是a[0]一维数组的首地址
			typeof(a[0][0])  ==> int 			 a[0][0]
=================================================================
	
	a+1		表示的是二维数组的第二个一维数组
			&a[0] + 1							 &a[1] (第二行)
			&a[1]
			int[4]* + 1
			
	&a[1]	指针,指向二维数组的第二个一维数组
			typeof(a[1]) *						&a[1]
			
	&a      指针,指向二维数组a
			typeof(a)*
			int[4][3] *                         &a
												在数值上就是a[0][0]地址(&a[0][0])
	
	&a+1   	表示跳过整个二维数组a的存储空间
			表示的是a[2][3]后面的那个地址       3*4*4 + &a[0][0]1
												
			
			
	有一个二维数组a[3][4];
	通过所有您已知的方式 对 a[2][2] 赋值 1024
	 
	a[2][2] = 1024;  //直接赋值
	int *q = &a[2][2]; //int *q;q = &a[2][2];
	*q = 1024; //通过变量地址间接赋值
	*(a[2]+2) = 1024;//a[2]表示的是二维数组的第三个(行下标为2)一维数组
	
	int (*w)[3][4] = &a; //指针w指向整个数组a
		w == &a; 
		*w == *(&a);
		*w == a;
		a[0] == &a[0][0];
		a == &a[0]; //a是数组名,是常量指针,指向数组的第一个元素
				//对于二维数组来说,第一个元素就是第一个一维数组
		*w == &a[0]
		*w+2 == &a[2]
		*w+2 == a + 2  == &a[2]
		*(*w+2) ==*(&a[2]) == a[2]
		*(*(*w+2)+2) == *(a[2] + 2) == *(&a[2][2]) == a[2][2]
	*(*(*w+2)+2) = 1024;
	
	
	int a[10] = {1,2,3,4,5,6,7,8,9,0};  //---->a       x
	
	int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};//----> b    y
	
	printf("a:%p  a+1:%p  &a+1:%p\n",a,a+1,&a+1);
	
	printf("b:%p  b+1:%p &b[0]:%p &b+1:%p\n",b,b+1,&b[0],&b+1);
	
3.字符串 和 指针
	
	c语言中没有字符串类型,c语言是用过用一个char*来实现字符串的
		char *:表示一个指向字符型的指针
	用""引起来的就被称为字符串
		比如"字符串" ---> 就是一个字符串
	字符串会在结尾自动添加'\0',用来表示字符串到此结束了
	
	有字符串如下
		"123456789"  ---->该字符串在内存中占10个字节
	字符串都是常量,字符串是存放在内存的 .rodata段,是只读的数据,不能被改变
	int main(void)
	{
		char *s = "123456789";
		s++; //是向后指向一个地址
		*s++;//取s地址的变量后s向后移动
		*(s+1);//取s后面的那个地址的变量
		s = &a; //a是一个char型变量  将s改指向 a的地址
		*(s+1) = 'A'; //给s后面地址的变量赋值为'A'
	}
	
	
	------>如果用指向char型的指针指向一个字符串,
			那么该指针指向的是字符串的首地址
			
	写一个函数,实现两个字符串比较(strcmp):通过字符串中每个字符的大小来比较		
	
	
	
4.字符串的操作函数
	输入函数:
		gets
		char *gets(char *s);
			参数:s:字符指针,需要以指向某个能够存放字符数据的地址空间
		返回值:获取到的字符串的存放地址(首地址)
		
		gets是用来从键盘获取字符串给指定的 "字符指针"
		char *p; //p指向任意地方,很危险!!
		p = gets();// p指针指向 gets获取到的字符串的首地址
		
		char *t = malloc(100);
		gets(t); //从键盘获取字符串,并存入t指针指向的地址
		
		gets(p); //不能用!!!! p只是一个指针,并没有空间
****gets的参数必须是一个已经分配了空间的字符指针(字符数组,malloc/realloc/calloc)	
------------------------------------------------------------------------		
	输出函数:
		puts将s指针指向的那个字符串输出到终端(打印)
		int puts(const char *s);
			参数:s表示要输出的字符串  
			puts(p);  <==>  printf("%s\n",p);
		
---------------------------------------------------------------------------		
	长度函数
		strlen:求字符串s的长度
		NAME
       strlen - calculate the length of a string

		SYNOPSIS
       #include <string.h>

       size_t strlen(const char *s);
****strlen求长度是遇到'\0'才截止

-----------------------------------------------------------------------------		
	比较函数
		strcmp/strncmp
		NAME
       strcmp, strncmp - compare two strings

		SYNOPSIS
       #include <string.h>
			strcmp:比较字符串s1和字符串s2的大小
			根据两个字符串的每个字符ASCII码来一一比较
       int strcmp(const char *s1, const char *s2);
			返回值: >0 表示 s1大于s2
					<0 表示 s1 小于s2
					==0 s1和s2中每个字符都相等
					
			strncmp:比较两个字符串的前n个是否相等
       int strncmp(const char *s1, const char *s2, size_t n);
****
	char *p = "abcd";
	char *q = "abcd";  
	//p指针和q指针指向的是  同一个地址!!!!!
	printf("%p  %p\n",p,q);

-----------------------------------------------------------------------	
	拷贝函数
		strcpy/strncpy
		NAME
       strcpy, strncpy - copy a string

	SYNOPSIS
       #include <string.h>
			strcpy将src字符串拷贝到dest字符串中,会整体拷贝,包括后面的'\0'
       char *strcpy(char *dest, const char *src);
			strncpy拷贝src的前n个字符 存放到dest指向存储空间中
	   char *strncpy(char *dest, const char *src, size_t n);
			从dest的第一个字符开始"替换"
--------------------------------------------------------------------------

		
	追加粘贴函数
		strcat/strncat
--------------------------------------------------------------------------		
	查找子字符串函数
		strstr
		NAME
       strstr, strcasestr - locate a substring

		SYNOPSIS
       #include <string.h>
			strstr用来在haystack中查找与needle相同的子字符串(查找)
       char *strstr(const char *haystack, const char *needle);

		返回值:失败返回NULL
			成功返回值找到的子字符串的首地址
			
		比如:
			strstr("ouyanghualiang","liang");
			
			
如果有一个数 是 12345678910111213141516 * 16151413121110987654321
	利用字符数组做大数据乘法
	char a[] = {'1','2',3,4,5,6,7,8,...,1,5,1,6};
	char b[] = {'1','6',.............,5,4,3,2,1};
	char tmp[] = ?
	char num[] = ?