定义函数的格式
	返回值类型   函数名(形参列表)
	{
		函数主体语句;
	}
	
	返回值类型:指return后面跟的那个表达式的 类型
	函数名:标示符
	形参列表:函数输入的条件,用来接收调用时传递过来的 "数据"
		----->参数的传递是一个赋值的过程
	函数主体语句:函数实现某个功能的具体执行代码
		----->算法

	(1)明确函数要实现什么功能?
		---->确立一个函数的大体框架(伪代码),函数名
		
	(2)实现该功能需要什么输入条件??
		---->确定函数需要的参数列表
		
	(3)完成该功能后会得到一个什么样的结果???
		---->确定函数的返回值类型
		
	(4)该功能要如何实现????
		---->具体算法/优化算法
		

调用函数的格式
	一个函数表达式,就可以实现函数的调用了
	
	函数名(实参列表); ------->函数表达式
	
	函数名:表明要调用的是哪个函数
	实参列表:传递给被调用函数的数据
		------>赋值给形参
		
	{被调函数返回值类型  变量名 = }函数名(实参列表);
	注:上面的表达式中,{}扩起来的部分,可要可不要
	
		scanf
		getchar
		
		scanf("%c",&a);
		a = getchar();

	**实参跟形参的数量要一致
	**实参跟形参的类型要一致
	
	int add(int a,int b,int c,int d);
	add(1,2,3,4);
	
	int q = 1;
	int w = 2;
	int e = 3;
	int r = 4;
	int t = add(q,w,e,r);
	======>
	在参数传递过程中:	
		如果是基本数据类型,实参跟形参对应的地址空间是不同的
		如果是其它数据类型,那么就不一定了
		比如:数组的传递,实参传递过来的是数组的首地址
				
		形参接受的也是数组的首地址
					此时形参跟实参是相同的地址空间!!!!!
			----->如果是地址传递,那么形参跟实参地址空间相同
		
		void print(int a[])
		{
			sizeof(a) == 4; //等于一个指针的大小
		}
		
		int a[100] = {1,2,3,4,5,6,7};
		sizeof(a) == 100;
		print(a);
		
		int t;
		typeof(t);  ----> 一个int型
		int k[10];
		typeof(k);  ----> 10个int型数据的数组
						----> int[10]
		
声明函数的格式
	定义的函数在调用的后面或者是在其它文件中,那就需要声明一下
	
	声明:就是告诉编译器,我已经定义了一个该函数了
	
	返回值类型 函数名(参数类型列表);
	
	int add(int ,int);
	int add(int a,int b);
	
	
	
	
	
	
	
	
递归函数:
		函数在执行过程中,直接或间接的调用了函数本身
		
		直接调用:在函数中直接调用自己
		间接调用:先调用别的函数,再从别的函数中调用自己
		
		
		递:自己调用自己  (是男人就下100层)
		归:满足了某个条件后,函数返回
		
	
		int F(int n)
		{
			if(n == 1 ||n == 2)
			{
				return 1;  //归
			}
			else
			{
				return F(n-1) + F(n-2); //递
			}
			
		}
	
	
	汉诺塔:
		游戏规则:从 源柱子上借助 中间柱子,将盘子移动到 目标柱子
				每次只能移动一个,并且大的盘子不能在小的盘子上面
		
		假设有一个人能帮我们完成整个任务
			那么这个人需要直到什么事情呢??
			这个人需要知道的是以下几点:
				要移动多少个盘子?  int
				源柱子是哪一根? char
				能借助的柱子是哪一根? char
				要移动到哪根柱子? char
				
		设这个人就是
			/*
				n是要移动的盘子个数
				i是源柱子
				j是中间柱子
				k是目标柱子
			*/
			H(int n,char i,char j,char k)
			{
				if(n == 1)
				{
					printf("end:%c---->%c\n",i,k);
				}
				H(n-1,i,k,j);//n-1个盘子,是要移动到中间柱子上,这个时候可以借用目标柱子		
				printf("mid:%c--->%c",i,k);//第n个盘子
				//执行完上面的步骤后,n-1个盘子在j上
				H(n-1,j,i,k);
			}
			
			
			
			
			
		int main(void)
		{
			H(20,'A','B','C'); // 20个盘子,从A上借助B移动到C
		}		
				
		
		
	假设一个人能帮我将数组小的数全部放在左侧,大的数全部放在右侧
		这个人需要直到什么事情??
			(1):数组是谁???
			(2):左侧是谁??? 最最边从哪开始
			(3):右侧是谁???
			
			归:只有一个元素的数组是没有左右的!!!!!
		/*建模*/
		SP(int a[],int left,int right)
		{
			设一个 标兵
			从标兵后一位开始与标兵比较
			如果比标兵大,则与最后一个位置交换,并且最后一个的编号前移一位(j--)
			否则 再往后一位比较(i++)
			直到 比较完(i==j)
			
			如果此时,i位置的数小于标兵位置的数,则两者交换
			左侧:[left,i-1]
			右侧:[i,rigth]			
		}
		
		
		
		将整个数组分为两端,小数全放在左端,大数全放在右端
		左右两端在次分,直到剩一个元素