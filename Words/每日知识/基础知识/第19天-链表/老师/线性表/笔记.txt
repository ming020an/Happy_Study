线性表     线性结构
	
	线性表:数据元素之间的关系是呈"线性关系"的
	
	比如:
		(A,B,C,D,E,F,....,X,Y,Z)         26个大写的英文字母 char
		(0,1,2,3,4,5,6,7,8,9)            10个基本的数字 int
		{{1,欧阳,89},{2,张三,79},...}    一个学生的成绩信息(struct student)
		.......
		
1.线性表的定义
	在线性表中,元素可以是多种多样的,但在同一个线性表中,
		元素的类型必定是相同的,也就是说,同一个线性表中
		各个元素具有相同的属性(数据类型)
		相邻的数据元素之间存在着"有序"的关系
		如果将线性表中的元素标记如下
		(a0,a1,a2,a3,a4,a5,a6,a7,......,ai,.....,an)
		(1)存在唯一一个被称为"第一个"的数据元素
		(2)存在唯一一个被称为"最后一个"的数据元素
		(3)除了第一个,所有数据元素都有一个前驱元素
		(4)除了最后一个,所有的数据元素都有一个后驱元素
		
		
		
2.线性表达物理结构表现
	要存储线性表,必须要存储两类东西
		D"数据"    S"逻辑关系"
		
	存储线性表时,物理结构主要有两种
	(1)顺序结构 (数组)
		用存储单元的 地址的物理关系来表示数据元素之间的逻辑关系
		逻辑在前的元素 存储地址也在前
		逻辑在后的元素 存储地址也在后
		
		最具代表性的顺序结构----->数组
		int a[10] = {34,21,56,33,71};
			a[0]   34
			a[1]   21
			a[2]   56
			a[3]   33
			a[4]   71
			....
			各个元素的物理地址(存储结构)的先后顺序:从低地址到高地址依次存放数组元素
			数组元素的逻辑关系是:a[0] 是数组的第一个元素
								 a[n-1] 是数组的最后一个元素
				物理关系 -----> 逻辑关系
				
		对于数组,最常用的操作有
			增  删  改  查
			时间复杂度 一般用O(..)表示
				如果没有循环 O(1) 常量时间
				如果有循环 O(n)  O(n^2)  O(n^3) ....
						   O(nlog2n) O(n!)	
				时间复杂度表示所关心语句的执行次数		   
			
			增: O(n)
				先找到插入位置
				后挪(一个一个的往后移动)

			删: O(n)
				先找到要删除元素的位置
				前挪(一个一个的往前挪)
			
			改:O(1)
				a[4] = 10;
			查:O(1)
				a[4]
		顺序结构最大的优点:
			简单 查找(修改)方便
		缺点:
			增加 和删除不太方便,因为要移动过多的元素
			
		有人就提出了,一定要用物理结构来表示逻辑结构吗???
		并不是的,每个元素存在物理上的哪个位置其实并不紧要
		只需要有办法找到这个"位置"就可以了啊!!
		"指针"就可以呀!!
		
		存储一个数据的时候,同时将它前面那个数据 或 后面那个数据
			的地址也存一下,是不是就可以了呢???
			
			100,0x12345678   -----> 0x2345455
			200,0x23456789   -----> 0x12345678
			300,0x34567890   -----> 0x23456789
			400,NULL         -----> 0x34567890
			
				
		这种存储方式:
			存储一个数据,同时存储它 前一个 或 后一个 数据的地址的存储方式,被称为链序存储(结构)
			
	(2)链序结构   ----> 链表
		在存储线性表时,不一定要用连续的地址存储,可以任意的在内存任何
		地方存放数据元素,只不过需要存储你下一个 或 上一个元素在内存中的位置就可以了 .....
		
		也就是说链序方式存储数据需要存储两种东西
			数据元素
			相邻位置
			------->结构体可以同时存放多个不同类型的数据
			
		设:数据元素的类型为  ElemType
		
		近期的链表存在结构体定义如下
		struct node ------->存储单个数据元素及下一个(上一个)元素的地址
		{
			ElemType data; ----> 存储"数据"     数据域 
			struct node *next; ----->存储下一个元素的地址   指针域
		};
		
		
		
		可不可以让"别人"来帮我创建一个链表呢????
		
		比如: struct node * create_linkedlist() 这人就能帮我们创建链表
		
		教学练习:写一个程序,用链表存储用户输入的数据,直到输入0为止
				最后将链表打印
				
			"想"的过程:
				链表是由一个一个的"结点"组成
				用户输   入一个数我就创建一个"结点"保存
				
				将结点插入链表
					无链表: "结点"就是链表第一个
					有链表: 尾插法  "结点"插到链表最后面
								last->next = p;
								last = p;
							头插法  "结点"插在链表最前面
								p->next = first;
								first = p;
							有序插入 每次插入一个元素前,都需要先找到
									要插入的位置
			思考:如何让链表在插入时有序
				"有序链表"
		
		无头结点单链表
		
		带头结点双链表
		
		双向链表
		
		循环链表
		.....
		
		练习:
			0.写一个程序,新建一个链表,数据由用户输入,
				要求先输入的在前面---->尾插法
				struct node*create_link(void)
				{
					struct node* first = NULL;
					struct node * last = NULL;
					struct node * p = NULL; //用来指向分配的空间
											//以存储用户输入数据
					int n;
					while(1) //循环接受用户输入
					{
						/*0.用户输入数据*/
						scanf("%d",&n);
						if(n == 0)
							break;
						
						/*1.分配一个结点大小的空间,保存用户数据*/
						p = (struct node *)malloc(sizeof(struct node));
						p->data = n;
						p->next = NULL;
						
						/*2.将结点插入链表*/
							/*2.1没有链表*/
						if(first == NULL)
						{
							first = p;
							last = p;
						}
							/*2.2有链表*/
						else
						{
							last->next = p;
							last = p;
						}
					}
					return first;
				}
				
			1.写一个程序,由用户输入数据,并且在插入时,降序排列
				struct node*create_link(void)
				{
					struct node* first = NULL;
					struct node * last = NULL;
					struct node * p = NULL; //用来指向分配的空间
											//以存储用户输入数据
					struct node * now = NULL;
					struct node * pre = NULL;
					int n;
					while(1) //循环接受用户输入
					{
						/*0.用户输入数据*/
						scanf("%d",&n);
						if(n == 0)
							break;
						
						/*1.分配一个结点大小的空间,保存用户数据*/
						p = (struct node *)malloc(sizeof(struct node));
						p->data = n;
						p->next = NULL;
						
						/*2.将结点插入链表*/
							/*2.1没有链表*/
						if(first == NULL)
						{
							first = p;
							last = p;
						}
							/*2.2有链表*/
						else
						{
							now = first;
							while(now)//遍历现有的链表,找插入位置
							{
								if(now->data < p->data)
								{
									break;
								}
								/*记录now的位置,然后now后移*/
								pre = now;
								now = now->next;
							}//结束循环的可能有两种now==NULL或now->data< p->data
							if(now == NULL)
							{
								/*最小的*/
								last->next = p;
								last = p;
							}
							else if(now == first)
							{
								/*最大的*/
								p->next = first;
								first = p;
							}
							else
							{
								/*不大不小*/
								p->next = now;
								pre->next = p;
							}
							
						}
					}
					return first;
				}
				
			2.写一个函数,在上题的链表中查找值为x(用户输入)的结点,多少个x
				p = first;
				int s = 0;
				scnaf("%d",&x);
				while(p)
				{
					if(p->data == x)
					{
						printf("找到了!!!!!");
						//break;
						s++;
					}
					p=p->next;
				}
				
				
			3.写一个函数,将上题的链表中 数值为 x(用户输入)的结点删除
				a.找到要删除的结点
				b.先转接再删除(把结点独立出来)
			
			要求:在敲代码的过程中,不准看我的示例代码!!!!
			
			
	链插入,先定位,再连线,后转接
	链删除,先定位,再转接,后free
	
	作业:
		0.删除一个链表中的所有x(用户输入)
		1.使一个链表中不存在重复元素
			1 1 1 1 1 2 2 2 2 2 3 3 3 3 4 4 4 4 4  5 5 5 5 
			----> 1 2 3 4 5 
		2.链表就地(不借助新的链表/结点)倒置
			1 2 3 4 5 6 7 8 9
			----> 9 8 7 6 5 4 3 2 1
		3.有一个9位以内的数(用户输入),请用链表将该数的每个位倒序存放
			123456789
			----> 9 8 7 6 5 4 3 2 1
			
		
3.带头结点的单链表	
	头结点:是一个特殊的结点,用来标识一个链表的存在,以及记录链表的相关信息
	
	struct list //链表的头结点
	{
		struct node *first; //指向链表第一个结点的指针
		struct node *last;  //指向链表最后一个结点的指针
		int num; 		   //记录链表结点的个数
	};
	
	
	
	练习:
		0.利用带头结点的链表,将 用户输入数据升序排列
		1.利用一个带头结点的链表,管理班级学生的期末成绩
			班级是头结点: 需要的信息如下
				语数外平均分
			学生结点:语数外成绩,学生姓名,学号
			
			输出格式如下:
			
		学号       姓名      班级     语文     数学   英语   平均分	
		  1        欧阳		 18139    99        98     97      98
		  2   	   华亮      18139    55        56     57      56
		  ......
		  
	sum(班级人数)  平均分     18139    000       000    000     000  
		
		struct student
		{
			int id;
			char name[50];
			int class;
			float yw;
			float sx;
			float yy;
			struct student * next;
		};
		
		
		
		struct class
		{
			int clanum; //班级
			int clasum; //人数
			float yw;  //语文总分(平均分)
			float sx; //数学总分(平均分)
			float yy; //英语总分(平均分)
			struct student * firs;
			struct student * last;
		};
		
		伪代码(完整的思路)
		/*0.创建头结点*/
			定义一个头结点结构体 分配空间 并 初始化赋值
			list->clanum = 18139;
			.......
		
		/*1.利用头结点来创建一个链表*/
			1.1定义一个结点结构体,分配空间,并初始化赋值(除指针外,可以由键盘输入)
				struct student *p = (struct student*)malloc(sizeof(*p));
				p->next = NULL;
				scanf("%d %s %d %f %f %f",&p->id,p->name,&p->class,&p->yw,&p->sx,&p->yy);
			1.2将结点插入链表
				1.2.1 链表不存在
					......list->first = list->last = p;
				1.2.2 链表存在
					......
			1.3更改头结点中的相对数据
				list->yw += p->yw;
				list->sx += p->sx;
				.....
				
		/*2.打印*/	
			......
			
			
			
	2.归并两个有序链表,并且归并后链表依然有序(两个都是带头结点的单链表):
		有两个有序链表 
		A 1 3  5 7 9 
		B  2 4 6 8 10
		----> A	1 2 3 4 5 6 7 8 9 10
		
		LIST* gb_linked(LIST *l1,LIST *l2)
		{
			
		}
		
	3.	链表有h个数(正负),是个无序链表,要求通过一个函数将负数放到正数前面(不要求有序)
		LIST* change_linked(LIST * l)
		{
			
		}
		
	4. 返回一个单链表中,倒数第n个结点的指针
		1 2 3 3 4 5 6 7 8 9
	
	*5 现有一个单链表,判断该链表是否有环(有没有一个指针指向了原本已经在链表中的结点)
	
	单循环链表作业
		有一群小朋友在玩游戏,
		总共N个小朋友,站成一个圈
		循环报数,从1开始报数,报数到3的同学出列,剩下的同学
		从下一个同学开始,继续1到3报数
		问:最后剩下的是哪个同学(小朋友编号从1开始)