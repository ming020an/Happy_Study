c语言程序的组成:
预定义:
	以#开头的表示预定义
		#include   -----> 用来包含入头文件
		#define    ------>  用来定义字符常量,一般来说字符常量
						都必须由大写字母 和 _ 组成(数字)
			比如 : #define PI  3.14159
			
	***预定义一般在文件的最开始部分,先头文件再是宏定义
	
		比如:
			#include <stdio.h>
			#include <string.h>
			
			#define  PI   3.14
			#define MAX(A,B)  A>B?A:B  //求两者中最大的数

			int main(void)
			{
				printf("%f\n",PI);
				int a = MAX(3,6); // a == 6
			}
			
全部变量部分:定义在函数外面的定义被称为全局变量
	函数声明部分:声明在文件中(在项目中)定义了一个函数
	全局变量的定义: 定义的全局变量在整个函数(整个项目中)都能使用(访问)

	
函数部分:定义一个函数,并且编写函数执行的指令语句
	比如: int main(void)
		  {
			printf("hello world!\n");
		  }
		  
------------------------------函数(function)--------------------------------------		  
0.问题引入
	for(i=0;i<N;i++)
	{
		printf("%d",a[i]);
	}
	printf("\n");
	
	
	for(i=0;i<M;i++)
	{
		printf("%d ",b[i]);
	}
	printf("\n");	  
			
	有没有办法让"别人"来帮我们打印这些数组,而不是"我们"每次都写循环呢??
	====>这个时候您就需要一个"别人"  -----> 函数
	
1.函数
	什么是函数?
	函数是完成某个 特定功能 的指令序列集  ----> 一个函数只能完成一个功能
	使用函数最大的好处是-----> 函数可以实现复用
	使整体程序的结构清晰化
	
	在结构化程序设计者的眼中,所有的项目(工程)都是由多个功能组成的
	
	结构化设计者主张将一个程序分成多个函数组成
	
		写一个函数,这个函数可以帮我们 累计两个数的 和
			int add_fun(int a,int b)
			{
				int c = a + b;
				return c;
			}
				//以上就是我们所说的 "别人"
				
	从上面的那个"别人",我们能够看出定义一个函数需要什么东西吗???
	
2.函数的组成
	返回值类型  函数名(参数列表)
	{
		指令序列集;
	}
	
	
	返回值类型:函数返回的那个数据的  数据类型
		可以是 c语言中任意合法的数据类型
		(基本数据类型/构造数据类型/指针数据类型/空类型)
		
	函数名:函数的名称,要符合c语言标示符的命名规范
	
	参数列表:功能模块的输入参数,形式参数(形参)
			不需要参数: void
			也可需要一个或多个参数:
				用逗号表达式隔开这多个参数
			参数格式如下:
				数据类型1 参数1,数据类型2 参数2,数据类型3 参数3,........
			例如:
			(int a,int b,char c,float *t,double k[])
			(void)
	
	指令序列集:函数主体部分,它是规定了函数所实现的功能的全部代码
		声明(定义)变量;
		语句部分;
		
		
	比如:写一个打印数组的函数如下:
		  // a是用来接受数组的参数
		  // n是用来接受数组元素个数的参数
		void pirnt(int a[],int n)
		{
			int i;
			for(i=0;i<n;i++)
			{
				printf("%d ",a[i]);
			}
			printf("\n");
			//return;  //这样是可以的
			//return 0; //这个是不对的,因为print函数的返回值类型是 void,不需要返回值
		}		
		
	返回值:就是该函数 return后面那个表达式的 值
			这个值必须与 函数返回值的类型 一致
			
			
	这个print可以帮助我们打印一个数组,那么,这个print什么会执行呢???
		======>调用的时候才会执行

3.函数的调用过程
	函数的调用:调度一个函数去执行
	格式:
		函数名(参数1,参数2,......);   //函数调用表达式
	int a[10] = {1,2,3,4,5,6,7,8,9,0};
	print(a[],10);
	
	******注意:调用函数其实就是一个语句
				语句只有在函数内部才能够存在
				
				
	函数的调用过程:
		把实参赋值给对应的形参,
		然后"跳转"调用的函数中去执行
		调用的函数遇到return表示调用的函数执行完了
		并且整个函数的执行结果就是return后面表达式的值
		
	strcat:将后一个字符串粘贴到前一个字符串
	strcat(a,b);
	第一个字符串: char a[] = "abcdefg"; //'\0'的下标是多少
				strlen[a] == 7;
				a[7] ---> '\0'
	第二个字符串: char b[] = "qwertyu";
	------>return abcdefgqwertyu\0;
	
	a[strlen[a]]  -----> '\0' ----> b[0]
	a[strlen(a)+1] = b[1];
	......
	a[strlen(a) + strlen(b) -1] = b[strlen(b)-1]; //u
	
	/*
		my_strcat 是将b字符串粘贴到a字符串后面
			a  表示粘贴到a这个数组
			b  表示要粘贴的是b数组中的元素
			n  表示要粘贴的个数
	*/
	char * my_strcat(char a[],char b[],int n)
	{
		int an = strlen(a);
		int bn = strlen(b);
		int i;
		/*
		for(i=0;i<=bn;i++)   //拷贝整个b字符串
		{
			a[an+i] = b[i]; //b[bn] == '\0'
		}
		*/
		for(i=0;i<n;i++) //拷贝b字符串的前n个
		{
			a[an + i] = b[i];
		}
		a[an + i] = '\0';
		 
		return ;
	}
	
	
	****注意:
		调用函数时,根据被调用函数的格式传递参数就可以了!!
	练习:	
	写一个函数,实现 找出两个数的最大值
	通过在main函数中调用该函数,并打印出最大值
		
	"目标 推导 过程"				
	想法:
		参数:	找两个数的最大值??  --->  需要两个数int a,int b
		函数主体:	最大值??  ----> 比较
		返回值类型:		返回值??  -----> 返回最大的那个数
		函数名:自己想!!!!
		
		int max(int a,int b)
		{
			if(a>b)
				return a;
			else
				return b;
		}
		
		
		int main(void)
		{
			int a,b;
			scanf("%d%d",&a,&b);
			int c = max(a,b);
			printf("max value is:%d\n",c);
		}
		
		
	找出一个数组的最大值
		参数: 数组的最大值:  数组   数组元素个数
		函数主体: 比较数组中的每一个数,看谁最大
		返回值类型: 返回一个最大的 数   int
		函数名: 取一个好听点的啊!能够让别人知道是你"儿子"啊
		
		int sz_max(int a[],int n)
		{
			
		}
		
		
	写一个函数,判断一个数中有多少个位是 1 
	
	
	0~0 0100 1101 0010    (1234)
	&: 取出指定位
		每次取出最低位  跟 1 相与   如果为 真   表示改位为1
						如果是假  表示该位为 0
						
		如果 x & 1 == 1   ----> 有一个1
			x>>1 & 1 == 1  ----> +1
			x>>2 & 1 == 1  ----> +1
			.....
			x>>(sizeof(x)*8-1)
	
	
		优化: 1<<n
	
	思路:
		(1):明确函数的功能是什么?     求一个数的 位上 1的个数
				----->想出对应的算法(程序应该怎么敲)
			函数名: num_byts
			
		(2):完成这个功能需要输入什么条件?   1个数
			参数: int num
			
		(3):完成这个功能的输出结果是什么?   1的个数
			返回值: 类型为 int
			
		(4):算法的实现以及优化
			  优化算法
			  
	int num_byts(int num)
	{
		/**
		if(num & 1 == 1)
		{
			++;
		}
		
		if(num >> 1 & 1 == 1)
		{
			++;
		}
		
		if(num >> 2 & 1 == 1)
		{
			++;
		}
		
		...
		
		if(num >> 31 & 1 == 1)
		{
			++;
		}
		***/
		for(i=0;i<32;i++)
		{
			/*
			if(num>>i & 1)
			{
				n++;
			}
			*/
			if(num & 1<<i)
			{
				n++;
			}
		}
		
		return n;
	}
	
	
	设:已存在一个数组,该数组中有16个数
	问:该数组中有没有可能找到一个元素的组合
		加起来和等于 N(从键盘获取)
		
	比如: {1,2,3,4,5,6,7,8,9,10};
	unsigned int a;
	a = 1;
	00000000000000~ 0001
	
	N=26;
	
	用一个整数表示数组中每个数有没有被选中,
	这个数每一个比特位对应数组中一个元素
	如果该元素对应位为 1  表示被选中
					为 0  表示没被选中
					
	s = 0;
	
	a>>1 & 1 == 1
		s += a[1] 被选中
	s == N ?
	
	a>>7 & 1 == 1
		a[7] 被选中
	
	"排列组合问题"
	000000~0000   ---->表示全不选
	000000~0001   ---->只选a[0]
	.....
	111111~1110   ----->自有a[0]不选
	111111~1111  ------>全选
	
	1000,2000,3000, 1,2,3,4,2000,-993
	6
	
	a 的取值范围是 [0,2^16-1]
	
	0000 0000 0000 0000   (0)
	0000 0000 0000 0001
	0000 0000 0000 0010
	0000 0000 0000 0011
	0000 0000 0000 0100
	.....
	1111 1111 1111 1111  (2^16-1)
	>>>>>>>>>>>>>>>>>>>>>>从这可以看出 a本身就是一个循环
	
	a有多少个位是1 --------> 又需要一层循环
	
	N = 6;
	t[16] = {2,1,5,4,8,7,3,6,5,4,1,9,8,7,1,2};
	for(遍历每一个a的可能性) // 0x0 ~ 0xffff   a = 0xf8;
	{
		for(j遍历a的每一位)// 0 ~ 15
		{
			if(a的该位为1) //a>>3 & 1
			{
				s+ = t[j]; // s+= t[3] + t[4] + t[5] + t[6] + t[7];
			}
		}
		if(s == N)
		{
			yes;
			break;
		}
	}
	
	
	
函数:
	定义函数的格式:
	返回值类型  函数名(参数列表)
	{
		变量声明;
		主体语句; // 统称为函数主体
	}
	
	比如:
	int add(int a,int b)
	{
		int c = a + b;
		return c; //return表示返回,结束函数
				 //return后面跟着的数 表示返回给调用函数的结果
	}
	
	函数调用:
	int main(void)
	{
		int n = add(4,5); // n == 9;
	}
	
	
	
4.递归函数:在函数中直接或者间接调用本身

	****注意:在定义递归函数的时候,一定要有一个结束的条件
	
	//斐波拉契递归函数
	int F(int n)
	{
		if(n==1 || n==2) //确定了结束递归的条件
		{
			return 1;
		}
		else
		{
			return F(n-1) + F(n-2);
		}
	}
	
	
	int main(void)
	{
		int k = F(3);
		printf("%d\n",k);
	}
	
	求 第10项
	
	已知  a1 = 1,a2=1,并且满足
	a3=a2+a1,
	a4=a3+a2
	以此类推
	an = a(n-1) + a(n-2);
	
	a10 = a9 + a8
	 = (a8+a7) + (a7+a6)
	 = ((a7+a6) + (a6+a5))                      +  ((a6+a5) + (a5+a4))
	 = (((a6+a5)+(a5+a4)) + ((a5+a4) + (a4+a3))) + (((a5+a4) + (a4+a3))+((a4+a3)+(a3+a2)))
	 = ......
	 = ((a2+a1) + (a2 + a1) + (a2 + a1) + ...........)
	 
	 
	//汉诺塔
	
		(1).功能:借助中间的柱子(废物)将源柱子上的盘子 移动到 目标柱子
		(2).实现这个功能需要那些参数
			 盘子有多少?  N
			 柱子编号? 'A' 'B' 'C'
		(3).算法:
				借助 'B' 将'A'---->'C'
		(4).打印移动的步骤
		
			比如:移动A上3个盘子借助B移动到C
			A-->C      B是废物
			A-->B	   C是废物
			C-->B      A是废物
			A-->C      B是废物
			B-->A
			B-->C
			A-->C
		思考题:	
		void hanot(int n,char a,char b,char c)
		{
			if(n == 1)
			{
				printf("%c--->%c\n",a,c);
				return 0;
			}
			else
			{
				n-1?移动到借助'废物'移动到'目标'  //把N上的移动到废物
				n?移动到'目标' //把N移动到 '目标'
				n-1? //把n-1也移动到 '目标'
			}
		}
		
		
		int main(void)
		{
			hanot(100,'A','B','C');
		}