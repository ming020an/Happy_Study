插入排序:"有序数组"的插入
	二分法插入
	
	
	设数组为 a[N];   N是数组容量   n是数组现有元素个数
	输入x需要插入到 a数组中
	low = 0;
	hight = n - 1;
	
	mod = (low+hight)/2;
	if(x > a[mod])// x应该插入到 右侧
	{
		low = mod+1;
	}
	else if(x < a[mod]) //x应该插入到左侧
	{
		hight = mod - 1;
	}
	else  //找到跟x相同的数
	{
		break;
	}
	
	if(hight < low)
	{
		break;
	}
	             
                  l  h     	
a:	1 3 5 7 9 11 13 15 17 19
x:	14
	
	low = 0;
	higth = 9;
	
	mod = (0+9)/2; //==4
	if(x>a[4])
		low = 5;  // mod + 1

	mod = (5+9)/2;
	if(x>a[7])
	{
	}
	else if(x < a[7])
	{
		hight = 6; //mod -1 
	}
		
	mod = (5+6)/2; //5
	if(x > a[5])
		low = 6; //mod + 1;
		
	mod = (6 + 6)/2; //6
	if(x > a[6])
	{
		low = 7; //mod + 1;
	}
	
	if(l > h)
	{
		//h+1就是我要插入的位置
	}
	
	//李鸿的想法是  if(h-l<=1)	break;
	
	
找规律------>建立模型(伪代码/思路一条条列举出来)

冒泡排序
	核心:比较相邻两个数,如果满足条件则交换位置
	比如:
		if(a[i] > a[i+1])  ---> 交换两个数的位置



选择排序
	核心:遍历整个数组,将最大的数与最后一个数的位置交换
	
	

	
快排:快速排序------>递归
	核心:通过一趟比较,将所有于 标兵的数放到后半段
			所有小于标兵的数放到前半段
	
	kuaipai(int a[],int lenght,int began,int end)
	
	第一轮:
		将所有小于标的放在左侧,所有大于标的放在右侧
		将标跟i交换位置
		
		
	标	i            j                    
	4   3    5   9   7    1    2    0    8	
		             i
	
			 8                           5
             0                      8	
	             2             9
                     1    7
					 
		if(i == j)
		{
			标 跟 i 交换
			
		}	
	1	             4

	分别将 [0~i]  和 [i+1,n-1]  调用函数本身,形成递归
	
	j<=i 结束递归
	
*****************快速排序数学模型***********************	
	设数组的第一个元素为 标兵 ,
	设数组第二个元素下标为i,最后一个元素小标为j
	
	比较 数组i  和 数组 标兵元素的大小
	
	如果 数组i的 大于 标兵  则将 数组i和数组j交换位置
			同时 j--;
	否则的话  i++
	
	当 i==j 时, 标兵跟i做交换
	
	然后 [0,i] 和 [i+1,n-1] 分别调用本身函数
	
	直到 j <= i
**********************************************************	