函数:完成某个功能的指令集

函数的设计(定义一个函数):
	(1):需要完成的功能是什么?  要做什么事情`!!!
	(2):完成这个功能需要什么条件??
		------>形参
	(3):完成在个功能后的结果是什么??
		------>返回值
	(4):优化:算法优化/代码简化
	
	
	int find_max(int a[],int n)
	{
		/*
		a[0] > a[1] ?
			a[0] > a[2]?
				a[0] >a[3]?
			a[1] > a[2]?
				a[1] > a[3]?
			a[2] > a[3]?
		*/
		/**
		int a_max = a[0];
		a_max > a[1] ?
			a_max;
		a_max = a[1];
		
		a_max > a[2]?
			a_max;
		a_max = a[2];
		
		a_max > a[3] ?
			a_max;
		a_max = a[3];
		**/
		int i; //循环计数,控制循环次数的
		int a_max;
		a_max = a[0];
		for(i=1;i<n-1;i++)
		{
			if(a_max < a[i])
				a_max = a[i];
		}
		
		return a_max;		
	}

	返回值类型 函数名(函数参数列表)
	{
		函数主体语句;
	}

函数的调用:调用一个已经定义好的函数去执行
	int b = find_max(a,10); //函数调用  接收返回值

	
	返回值类型 变量 = 函数名(传递的参数列表);
	
	
参数传递:
		传递的参数列表----->实参
		函数的参数列表----->形参
		
		
		实参------>形参 的传递过程,是在做什么呢??
		赋值的过程!!!!!!
		
		将实参当成右值
		将形参当成左值
		===>  函数参数列表 = 传递的参数列表
	例如:上面那个函数调用中
		a[] = a;
		n = 10;
		
		
		
		
	假设有如下函数:
	int add(int a,int b)
	{
		a = a+b;  //a = 3+4  ---> 7
		return a;
	}
	
	int main(void)
	{
		int a = 3;
		int b = 4;
		int c = add(a,b);
		
		printf("a=%d b=%d c=%d\n",a,b,c);
	}
	
	参数传递过程:   a = a;
					b = b;
					
	在函数调用中,
		形参和实参的名字可以相同
		但形参和实参的内存地址是不相同的
		=====>形参数值的改变不会影响到实参
		

	调用函数的返回
	***返回值只能有一个
	/*
		交换两个数的位置
	*/
	int a;
	int b;
	void jiaohuan() //形参也是局部变量
	{
		int tem;
		tem = a; //tem = 3
		a = b; // a = 4;
		b = tem; // b = 3;
	}
	
	int main(void)
	{
		a = 3;
		b = 4;
		jiaohuan();
		printf("a=%d  b=%d\n",a,b);//a=4  b=3
	}
	
=======>全局变量
什么是全局变量???
	定义在函数外面的变量叫做全局变量
	全局变量是定义给所有函数使用的
	
	
	int a;
	int b;
	char c;
	// a,b,c都是全局变量
	int add()
	{
		c = a + b;
	}
	
	int jh()
	{
		 c =a;
		 a = b;
		 b = c;
	}
	
c语言中变量的存储
	linux为了方便管理不同的数据
	将内存分为不同区域进行对数据的存储
	高地址--->
		栈 :用来存放局部变量
		堆 :用来存放动态分配的空间(malloc/realloc/calloc)
		.bss :未初始化的全局变量 和未初始化的 static 变量
		.rodata :read only data 用来存放只读数据
				常量/常量表达式/符号常量/数组名....
		.data: 
			用来存放初始化的全局变量和初始化的static修饰的变量
		.text:代码段,用来存放代码	
	低地址--->
	
static 修饰词,用来修饰变量的
	比如:
		static int a = 5;
		
	static是一个静态修饰词,被static修饰的那个变量
		会在程序开始执行时就分配空间,并初始化(如果有)
		如果在程序运行时再次遇上该语句,就不会执行了!!
		
	while(1)
	{
		int a = 5;
		printf("%d\n",a++);
		sleep(1);
	}	
	
	
	while(1)
	{
		static int a = 5;
		printf("%d\n",a++);
		sleep(1);
	}
	
	
	在程序运行前就执行的语句有:
		预定义:编译的时候就已经搞定了!!!!!!
		全局变量
		static修饰的变量
		
变量从存储角度来看,除了全局变量还有局部变量
	全局变量:定义在函数外面的变量叫做全局变量
		在程序一开始运行时就已经执行了(分配空间/初始化)
		并且在程序执行过程中,分配的空间不变
		作用是整个文件(加了static修饰)或工程(未加static修饰)
	
	工程----->多文件联合编译
	声明:
		(1)声明在文件中定义了某个函数/全局变量
			int a; //声明或定义一个全局变量
			int add(int ,int );//声明一个函数
		(2)声明在其它文件中定义了某个函数或变量
			外部声明:使用修饰符 extern
			extern int a; //在工程的其它文件中定义了一个
						//全局变量a
			extern int add(int ,int);//声明在工程的其它文件
						//中定义了一个add函数,返回值是int
						//参数是两个int
		多文件联合编译的编译方法:
	gcc 要编译的文件1 要编译的文件2 ... 
		要编译的文件n -o 生成的程序文件名
		
		它会将多个.c文件一起编译生成一个可执行程序
		
	比如:利用多文件联合编译,交换两个数的位置
		在 main.c中,有a = 10,b = 100;
		在 jx.c中,可以实现将 a b的值换位
		再到 main.c中输出换位的 a b的值
	局部变量:定义在函数 {} 扩起来的地方就叫做局部变量
	
	
	
	
	