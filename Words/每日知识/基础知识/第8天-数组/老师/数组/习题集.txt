求数组的最大值和最小值

	int a[10] = {1,9,4,8,3,7,2,5,0,6};
	a_max = a[0];//表示最大的数
	int i_max; //中间变量,用来临时保存关注的对象
	
	a_max < a[1]
		a_max = a[1];	
		i_max = 1;
					
	a_max < a[2] 
		a_max = a[2];
		i_max = 2;
	.....
	
	a_max < a[9]
		a_max = a[9];
		i_max = 9;
				
		====> a_max 就是数组的最大值
		
	
	int i = 0;
	int a_max = a[0];
	int i_max;
	
	while(i<10)
	{
		if(a_max < a[i])
		{
			a_max = a[i];
			i_max = i;
		}
		
		i++;
	}
	
	printf("max is a[%d]:%d\n",i_max,a_max);
	
	
找出一个一维数组的最小值,和第二大的值
	
	
	int i = 0;
	int a_max = a[0];
	int i_max;
	
	while(i<10)
	{
		if(a_max < a[i]) //找最大值
		{
			a_max = a[i];
			i_max = i;
		}
		
		if(a_min > a[i])
		{
			a_min= a[i];
		}
		
		i++;
	}
	
	/*第二大,就是排除最大那个后  最大的那一个*/
	//b_max = a_min;
	b_max = 0x80000000;
	for(i=0;i<10;i++)
	{
		if(i == i_max) //排除最大的那个数
		{
			continue;
		}
		
		if(b_max < a[i]) //找第二大的数
		{
			b_max = a[i];
		}
	}
	
	printf("max is a[%d]:%d\n",i_max,a_max);
	
	

#define N  10
#define M  10 

int a[N][M] = {0};
int flag = 1; //0表示没有鞍点  1表示有鞍点
for(i=0;i<N;i++)//遍历每一行
{
	for(找行最大值的)
	{
		a_max;
		i_max; //记住最大值的列坐标
	}
	
	//1.你老师最原始的low算法
	for(k找列的最小值)
	{
		if(a_min > a[k][i_max])
			a_min = a[k][i_max];
	}
	if(a_max == a_min)
	{
		andian++;
	}
	
	//(老胡的算法是) 直接用 a_max取跟同列的做比较,
	//看是不是最小的,只有 列中有一个比它小的,就不是了
	for(k=0;k<M;k++)
	{
		if(a_max > a[k][i_max])
		{
			flag = 0;
			break;
		}
	}
	if(flag == 1)
		andian++;
	
	flag = 1; //确保下次进入循环时,默认有鞍点
}
	
	

	
山顶问题:
	 设,要判断a[i][j]是不是山顶
	 
	(i-1<0  || a[i][j] > a[i-1][j]) &&
	(i+1>=M || a[i][j] > a[i+1][j]) &&
	(j-1<0  || a[i][j] > a[i][j-1]) &&
	(j+1>=N || a[i][j] > a[i][j+1])

	
矩阵倒置	
	for(;i<3;)
	{
		for(;j<4;)
			b[i][j] = a[j][i];
	}
	
	
三种经典排序算法
	1.插入排序:  
		主要用在向一个"有序数组"中插入数据
			后一个元素恒比前一个元素大:升序
			后一个元素恒比前一个元素小:降序
			{1,1,1,1,1,1,1,1,1,1,1,1,1} :升序  降序
			判断一个数组是否有序:
				(1)判断前两个元素是升序还是降序
					如果前两个元素是升序:按照升序的方式继续判断后面的元素
					如果前两个元素是降序:按照降序的方式继续判断后面的元素
					如果前面两个相等:继续向后判断
				(2) 判断 a[i] > a[i+1]  a[i+1] > a[i+2] 
		{1,5,4,2,1,7,32,8,2,1,7,1,39,5}
		for(i=1;i<14;i++)
		{
			//a[i] ----> 要插入的数据
			for(j=0;j<i;j++)
			{
				if(a[j]>a[i])
				{
					//j就是要插入的位置
					i_max = j;
					break;
				}
			}
			
			//插入:后移空出插入的位置,在插入
			for(j=i;j>i_max;j--)
			{
				a[i] = a[i-1];
			}
			
			a[j] = a[i];
			
			
		}
		
	**插入排序是比较稳定的排序
	
	2.冒泡排序: N
		两两比较,如果前者比后者大交换位置
		====>第一趟比较结束,最大的数在数组最后面 (N-1)
		
		
	
		for(i=0;i<N-1;i++)
		{
			if(a[i] > a[i+1])
			{
				tmp = a[i];
				a[i] = a[i+1];
				a[i+i] = tmp; //前后交换,大数在后头
			}
		}
		
		-===>第二趟比较结果,将第二大的数放在数组倒数第二的位置 (N-1-1)
		for(i=0;i<N-2;i++)
		{
			if(a[i] > a[i+1])
			{
				tmp = a[i];
				a[i] = a[i+1];
				a[i+i] = tmp; //前后交换,大数在后头
			}
		}
		
		-===>第三趟比较结果,将第三大的数放在数组倒数第三的位置 (N-1-1-1)
		for(i=0;i<N-3;i++)
		{
			if(a[i] > a[i+1])
			{
				tmp = a[i];
				a[i] = a[i+1];
				a[i+i] = tmp; //前后交换,大数在后头
			}
		}
		
		.....
		
		->>>>>>>>>>>最后一趟,确保第二个数大于第一个数
		for(i=0;i<N-(N-1);i++)
		{
			if(a[i] > a[i+1])
			{
				tmp = a[i];
				a[i] = a[i+1];
				a[i+i] = tmp; //前后交换,大数在后头
			}
		}
		
		
	===========>优化
		for(j=1;j<N;j++)
		{
			for(i=0;i<N-j;i++)
			{
				if(a[i] > a[i+1])
				{
					tmp = a[i];
					a[i] = a[i+1];
					a[i+i] = tmp; //前后交换,大数在后头
				}
			}
		}
		"目标推导过程"
	
	
	3.选择排序
		每次选择数组中最大的数,跟最后面没有定序的数交换位置
		====>第一次将数组最大的数放到数组最后面
			for(i=0;i<N;i++)
			{
				a_max = a[0];
				i_max = i;
				if(a_max < a[i])
				{
					a_max = a[i];
					i_max = i;
				}
			}
			tmp = a[N-1];
			a[N-1] = a[i_max];
			a[i_max] = tmp;
			
		====>第二次将剩下的数组中最大的数放到剩下的数组最后面
			for(i=0;i<N-1;i++)
			
			
			交换N-2 和最大数
			
		======>第三次将剩下的数组中最大的数放到剩下的数组最后面
			for(i=0;i<N-2;i++)
			
			
			交换N-3 和最大数
		.....
		
		======>最后一次
			for(i=0;i<N-(N-1);i++)  ----->只有a[0]一个数了
			
			
			
		