gcc 要编译的文件 -o 生成的文件名
	比如: gcc a.c -o a   -----> 生成一个叫 a 的文件,该文件是一个程序文件,并且是可执行的
			gcc ouyang.c -o hualiang 
				----> 编译ouyang.c文件,生成一个叫做hualiang的可执行程序文件 
	那么用这种方式编译的话,执行的时候 ./后面加的就是 生成的这个文件名了
		比如 ./a
			./hualiang


数组的操作函数
	用来对数组部分或整体进行赋值的操作:
	
	***对于数组来说:数组名其实就是一个指针,指向数组的首地址(数组第一个元素的地址)
		int a[10] = {1,2,3,4,5,6,7,8,9,0};
		*a = 1; //  a <==> &a[0]  ====> *a = *(&a[0]) = a[0]  = 1


	
----------------------------------memset------------------------------------------------	
	NAME
       memset - fill memory with a constant byte

	SYNOPSIS
       #include <string.h>
			memset用来给指定的存储空间赋值
       void *memset(void *s, int c, size_t n);
			s:指针,表示要赋值的那个地址
			c:整型数,表示要赋值的数据
			n:赋值大小,表示赋值多少个数据对象
		char buf[100] = "abcdefghijklmn";
			typeof(buf) ==  buf的类型是 100个char型的数组
			sizeof(buf) == 100
			strlen(buf) == 14
			
	常用于清空一个数组!!!
	
	
-----------------------------------bzero-----------------------------------------------	

	NAME
       bzero - write zero-valued bytes

	SYNOPSIS
       #include <strings.h>
			bzero用来将一个数组清零
       void bzero(void *s, size_t n);
			s:通用指针,可以给一个任意类型的指针(数组名)
			n:要清0的大小





字符数组的操作函数

---------------------------------strlen---------------------------------------
	NAME
       strlen - calculate the length of a string

	SYNOPSIS
       #include <string.h>
			strlen:用来计算一个字符串的长度,遇到'\0'截止,并且不计算'\0'
       size_t strlen(const char *s);
			参数 s :要计算长度的那个字符串指针
		返回值:计算出来的字符串长度,单位  字节
		
		
------------------------------strcpy-------------------------------------------	
strint  copy
	NAME
       strcpy, strncpy - copy a string

	SYNOPSIS
       #include <string.h>
			用来将src字符串拷贝到dest字符串中
       char *strcpy(char *dest, const char *src);
				dest:用来存放拷贝过来的数据的指针
				src:要拷贝的字符串指针
	   
	   
			用来将src的前n个字符拷贝到dest中
       char *strncpy(char *dest, const char *src, size_t n);
			n:要拷贝是数量,单位 字节
		
	strcpy会在拷贝之后添加入一个'\0'	
		
	***注意事项:在使用strcpy的时候,要确保dest的存储空间有足够大,否则  "段错误" 可能会跟您见面!!
	
		"段错误":一般在操作了不该操作的地址空间时,程序的执行会崩溃掉,并提示错误信息   段错误
			int a[10]; //  a[10] = 100;  a[-1]
			所以郑重提醒:不要在代码中存在数组越界的可能性
			
			char b[5] = "hello"; //数组越界
			char c;  // 很有可能 c == '\0';
			
------------------------------strcmp-------------------------------------------	
用来比较两个字符串的大小的
	注意:字符串的比较不能用 关系运算符 进行,只能用strcmp
	
	NAME
       strcmp, strncmp - compare two strings

	SYNOPSIS
       #include <string.h>
			strcmp用来比较两个字符串的大小
       int strcmp(const char *s1, const char *s2);
			strncmp用来比较两个字符串的前N个字符的大小
       int strncmp(const char *s1, const char *s2, size_t n);
	   
	   返回值: >0 表示 s1 > s2,只要遇到第一个能够比较出大小的字符就结束比较
			   <0 表示 s1 < s2
			  ==0 表示 s1 == s2  比较完了,都没有找到不相等的才能说两个字符串相等
	   
	   例如:
		char a[10] = "hehehe";
		char b[10] = "hahaha";
		int t = strcmp(a,b);
		
	***注意:字符串的比较是按照字符串中各个字符的ascii做比较,ASCII越大,数组越大


------------------------------strcat-------------------------------------------		
NAME
       strcat, strncat - concatenate two strings

SYNOPSIS
       #include <string.h>
			strcat将src字符串黏贴到dest字符串的后面
       char *strcat(char *dest, const char *src);

			strncat将src中的前n个字符 黏贴到dest字符串的后面
       char *strncat(char *dest, const char *src, size_t n);
			dest:表示用来接受黏贴字符串的那个指针
			src:被黏贴的那个字符串
			n:表示黏贴多少个字符
			
		比如
			char a[10] = "he";
			char b[10] = "nihaoa!!";
			strcat(a,b);
			printf("a:%s\nb:%s\n",a,b);
			printf("%d\n",strlen(a));
			
	***作用:剪切并粘贴

------------------------------strstr-------------------------------------------	

NAME
       strstr, strcasestr - locate a substring

SYNOPSIS
       #include <string.h>
			strstr:作用是用来在haystack中查找出一个 needle 的子字符串
       char *strstr(const char *haystack, const char *needle);
			返回值:失败,没有找到 needle这个子字符串的话,返回NULL(空)
					成功,找到了一个 needle的子字符串,返回值该子字符串的起始 地址
					
		比如: char a[100] = {"hello nihaoa zhe ge shijie"};
			  char *p = strstr(a,"zhe");
			  if(p == NULL)
			  {
				printf("no the needle\n");
			  }
			  else
			  {
				printf("%s\n",p);
			  }
			


斐波拉切阶数
	1 1 2 3 5 8 13 21 34 55 89 ............
	求前20项之和
		(1) 求第i项的数值
		(2) 求第i项的和

杨辉三角
			1                                            1    
			1   1                                        2
			1   2   1                                    3
			1   3   3    1                               4 
			1   4   6    4    1                          5
			1   5   10   10   5   1                      6
		    ........
			
			a[i][j] = a[i-1][j-1] + a[i-1][j];
			
			[i][0] == 1
			[i][i] == 1

		打印前10项
		%nd   n表示n个空格